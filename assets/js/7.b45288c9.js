(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{435:function(t,s,r){t.exports=r.p+"assets/img/20210518-chain.f5dbf766.jpg"},456:function(t,s,r){"use strict";r.r(s);var n=r(28),a=Object(n.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"链表"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),n("h2",{attrs:{id:"概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),n("p",[n("strong",[t._v("链表")]),t._v("是最简单的一种基于结点的数据结构。"),n("br"),t._v("\n与数组一样，链表也用来表示一系列的元素。与数组不用的是，组成链表的格子不是连续的。它们可以分布在内存的各个地方。这种不相邻的格子，就叫做"),n("strong",[t._v("结点")]),t._v("。"),n("br"),t._v("\n计算机如何知道这些分散的结点属于这个链表还是其他链表？每个节点除了保存数据，它还保存着链表里的下一个结点的内存地址。这个用来指示下一个结点的内存地址的额外数据就是"),n("strong",[t._v("链")]),t._v("。\n"),n("img",{attrs:{src:r(435),alt:"链"}}),t._v('\n此例中，我们的链表包含4项数据："a"、"b"、"c"和"d"。因为每个结点都需要2个格子，头一格用作数据存储，后一格用作指向下一结点的链（最后一个结点的链是null，因为它是终点），所以整体占用了8个格子。')])])}),[],!1,null,null,null);s.default=a.exports}}]);